use opcua_types::NodeId;

use super::NodeType;

pub use opcua_types::NodeSetNamespaceMapper;

#[derive(Debug)]
/// A reference produced by a type implementing [`NodeSetImport`].
/// Note that the source of this reference is given by the node in the outer [`ImportedItem`]
pub struct ImportedReference {
    /// Reference target ID.
    pub target_id: NodeId,
    /// Reference type ID.
    pub type_id: NodeId,
    /// Whether this is a forward or inverse reference.
    pub is_forward: bool,
}

#[derive(Debug)]
/// A node with associated references produced by a type implementing [`NodeSetImport`]
pub struct ImportedItem {
    /// The imported node.
    pub node: NodeType,
    /// The list of imported references.
    pub references: Vec<ImportedReference>,
}

/// Trait for a type that wraps a nodeset import.
/// Currently this is implemeneted by the [`crate::xml::NodeSet2Import`] type
/// with the `xml` feature, and by a type in the root of node set imports generated by
/// `async-opcua-codegen`
pub trait NodeSetImport {
    /// Register all namespaces used by this importer in a node set map.
    fn register_namespaces(&self, namespaces: &mut NodeSetNamespaceMapper);

    /// Get a list of namespaces that this import _owns_. This must be a subset of the
    /// namespaces it uses, registered in `register_namespaces`
    fn get_own_namespaces(&self) -> Vec<String>;

    /// Create an iterator over items imported from the nodeset.
    /// This will usually be lazy.
    fn load<'a>(
        &'a self,
        namespaces: &'a NodeSetNamespaceMapper,
    ) -> Box<dyn Iterator<Item = ImportedItem> + 'a>;
}
