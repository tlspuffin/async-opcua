// This file was autogenerated from schema/Opc.Ua.Pn.Types.bsd by async-opcua-codegen
//
// DO NOT EDIT THIS FILE

// OPCUA for Rust
// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2017-2024 Einar Omang
#![allow(non_camel_case_types)]
#![allow(clippy::upper_case_acronyms)]
pub mod enums;
pub use enums::*;
pub mod structs;
pub use structs::*;
static TYPES: std::sync::LazyLock<opcua::types::TypeLoaderInstance> =
    std::sync::LazyLock::new(|| {
        let mut inst = opcua::types::TypeLoaderInstance::new();
        {
            inst.add_binary_type(
                crate::DataTypeId::PnDeviceDiagnosisDataType as u32,
                crate::ObjectId::PnDeviceDiagnosisDataType_Encoding_DefaultBinary as u32,
                opcua::types::binary_decode_to_enc::<PnDeviceDiagnosisDataType>,
            );
            inst.add_binary_type(
                crate::DataTypeId::PnDeviceRoleOptionSet as u32,
                crate::ObjectId::PnDeviceRoleOptionSet_Encoding_DefaultBinary as u32,
                opcua::types::binary_decode_to_enc::<PnDeviceRoleOptionSet>,
            );
            inst.add_binary_type(
                crate::DataTypeId::PnIM5DataType as u32,
                crate::ObjectId::PnIM5DataType_Encoding_DefaultBinary as u32,
                opcua::types::binary_decode_to_enc::<PnIM5DataType>,
            );
        }
        #[cfg(feature = "xml")]
        {
            inst.add_xml_type(
                crate::DataTypeId::PnDeviceDiagnosisDataType as u32,
                crate::ObjectId::PnDeviceDiagnosisDataType_Encoding_DefaultXml as u32,
                opcua::types::xml_decode_to_enc::<PnDeviceDiagnosisDataType>,
            );
            inst.add_xml_type(
                crate::DataTypeId::PnDeviceRoleOptionSet as u32,
                crate::ObjectId::PnDeviceRoleOptionSet_Encoding_DefaultXml as u32,
                opcua::types::xml_decode_to_enc::<PnDeviceRoleOptionSet>,
            );
            inst.add_xml_type(
                crate::DataTypeId::PnIM5DataType as u32,
                crate::ObjectId::PnIM5DataType_Encoding_DefaultXml as u32,
                opcua::types::xml_decode_to_enc::<PnIM5DataType>,
            );
        }
        #[cfg(feature = "json")]
        {
            inst.add_json_type(
                crate::DataTypeId::PnDeviceDiagnosisDataType as u32,
                crate::ObjectId::PnDeviceDiagnosisDataType_Encoding_DefaultJson as u32,
                opcua::types::json_decode_to_enc::<PnDeviceDiagnosisDataType>,
            );
            inst.add_json_type(
                crate::DataTypeId::PnDeviceRoleOptionSet as u32,
                crate::ObjectId::PnDeviceRoleOptionSet_Encoding_DefaultJson as u32,
                opcua::types::json_decode_to_enc::<PnDeviceRoleOptionSet>,
            );
            inst.add_json_type(
                crate::DataTypeId::PnIM5DataType as u32,
                crate::ObjectId::PnIM5DataType_Encoding_DefaultJson as u32,
                opcua::types::json_decode_to_enc::<PnIM5DataType>,
            );
        }
        inst
    });
#[derive(Debug, Clone, Copy)]
pub struct GeneratedTypeLoader;
impl opcua::types::TypeLoader for GeneratedTypeLoader {
    fn load_from_binary(
        &self,
        node_id: &opcua::types::NodeId,
        stream: &mut dyn std::io::Read,
        ctx: &opcua::types::Context<'_>,
    ) -> Option<opcua::types::EncodingResult<Box<dyn opcua::types::DynEncodable>>> {
        let idx = ctx
            .namespaces()
            .get_index("http://opcfoundation.org/UA/PROFINET/")?;
        if idx != node_id.namespace {
            return None;
        }
        let Some(num_id) = node_id.as_u32() else {
            return Some(Err(opcua::types::Error::decoding(
                "Unsupported encoding ID. Only numeric encoding IDs are currently supported",
            )));
        };
        TYPES.decode_binary(num_id, stream, ctx)
    }
    #[cfg(feature = "xml")]
    fn load_from_xml(
        &self,
        node_id: &opcua::types::NodeId,
        stream: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::Context<'_>,
    ) -> Option<opcua::types::EncodingResult<Box<dyn opcua::types::DynEncodable>>> {
        let idx = ctx
            .namespaces()
            .get_index("http://opcfoundation.org/UA/PROFINET/")?;
        if idx != node_id.namespace {
            return None;
        }
        let Some(num_id) = node_id.as_u32() else {
            return Some(Err(opcua::types::Error::decoding(format!(
                "Unsupported encoding ID {node_id}, we only support numeric IDs"
            ))));
        };
        TYPES.decode_xml(num_id, stream, ctx)
    }
    #[cfg(feature = "json")]
    fn load_from_json(
        &self,
        node_id: &opcua::types::NodeId,
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> Option<opcua::types::EncodingResult<Box<dyn opcua::types::DynEncodable>>> {
        let idx = ctx
            .namespaces()
            .get_index("http://opcfoundation.org/UA/PROFINET/")?;
        if idx != node_id.namespace {
            return None;
        }
        let Some(num_id) = node_id.as_u32() else {
            return Some(Err(opcua::types::Error::decoding(
                "Unsupported encoding ID. Only numeric encoding IDs are currently supported",
            )));
        };
        TYPES.decode_json(num_id, stream, ctx)
    }
    fn priority(&self) -> opcua::types::TypeLoaderPriority {
        opcua::types::TypeLoaderPriority::Generated
    }
}
