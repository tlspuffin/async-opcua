// This file was autogenerated from schemas/1.05/Opc.Ua.Types.bsd by async-opcua-codegen
//
// DO NOT EDIT THIS FILE

// OPCUA for Rust
// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2017-2024 Adam Lock, Einar Omang
#[allow(unused)]
mod opcua {
    pub use crate as types;
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessLevelExType : i32 { const
    None = 0i32; const CurrentRead = 1i32; const CurrentWrite = 2i32; const HistoryRead =
    4i32; const HistoryWrite = 8i32; const SemanticChange = 16i32; const StatusWrite =
    32i32; const TimestampWrite = 64i32; const NonatomicRead = 256i32; const
    NonatomicWrite = 512i32; const WriteFullArrayOnly = 1024i32; const NoSubDataTypes =
    2048i32; const NonVolatile = 4096i32; const Constant = 8192i32; }
}
impl opcua::types::UaNullable for AccessLevelExType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for AccessLevelExType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AccessLevelExType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for AccessLevelExType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessLevelExType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for AccessLevelExType {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for AccessLevelExType {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AccessLevelExType {
    const TAG: &'static str = "AccessLevelExType";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AccessLevelExType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AccessLevelExType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessLevelType : u8 { const None
    = 0u8; const CurrentRead = 1u8; const CurrentWrite = 2u8; const HistoryRead = 4u8;
    const HistoryWrite = 8u8; const SemanticChange = 16u8; const StatusWrite = 32u8;
    const TimestampWrite = 64u8; }
}
impl opcua::types::UaNullable for AccessLevelType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for AccessLevelType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        1usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_u8(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AccessLevelType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, ctx)?))
    }
}
impl Default for AccessLevelType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessLevelType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for AccessLevelType {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for AccessLevelType {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AccessLevelType {
    const TAG: &'static str = "AccessLevelType";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AccessLevelType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AccessLevelType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessRestrictionType : i16 {
    const None = 0i16; const SigningRequired = 1i16; const EncryptionRequired = 2i16;
    const SessionRequired = 4i16; const ApplyRestrictionsToBrowse = 8i16; }
}
impl opcua::types::UaNullable for AccessRestrictionType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for AccessRestrictionType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        2usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i16(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AccessRestrictionType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, ctx)?))
    }
}
impl Default for AccessRestrictionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessRestrictionType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for AccessRestrictionType {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for AccessRestrictionType {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AccessRestrictionType {
    const TAG: &'static str = "AccessRestrictionType";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AccessRestrictionType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AccessRestrictionType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AlarmMask : i16 { const None =
    0i16; const Active = 1i16; const Unacknowledged = 2i16; const Unconfirmed = 4i16; }
}
impl opcua::types::UaNullable for AlarmMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for AlarmMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        2usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i16(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AlarmMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, ctx)?))
    }
}
impl Default for AlarmMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AlarmMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for AlarmMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for AlarmMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AlarmMask {
    const TAG: &'static str = "AlarmMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AlarmMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AlarmMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ApplicationType {
    #[opcua(default)]
    Server = 0i32,
    Client = 1i32,
    ClientAndServer = 2i32,
    DiscoveryServer = 3i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AttributeWriteMask : i32 { const
    None = 0i32; const AccessLevel = 1i32; const ArrayDimensions = 2i32; const BrowseName
    = 4i32; const ContainsNoLoops = 8i32; const DataType = 16i32; const Description =
    32i32; const DisplayName = 64i32; const EventNotifier = 128i32; const Executable =
    256i32; const Historizing = 512i32; const InverseName = 1024i32; const IsAbstract =
    2048i32; const MinimumSamplingInterval = 4096i32; const NodeClass = 8192i32; const
    NodeId = 16384i32; const Symmetric = 32768i32; const UserAccessLevel = 65536i32;
    const UserExecutable = 131072i32; const UserWriteMask = 262144i32; const ValueRank =
    524288i32; const WriteMask = 1048576i32; const ValueForVariableType = 2097152i32;
    const DataTypeDefinition = 4194304i32; const RolePermissions = 8388608i32; const
    AccessRestrictions = 16777216i32; const AccessLevelEx = 33554432i32; }
}
impl opcua::types::UaNullable for AttributeWriteMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for AttributeWriteMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AttributeWriteMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for AttributeWriteMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AttributeWriteMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for AttributeWriteMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for AttributeWriteMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for AttributeWriteMask {
    const TAG: &'static str = "AttributeWriteMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AttributeWriteMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AttributeWriteMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum AxisScaleEnumeration {
    #[opcua(default)]
    Linear = 0i32,
    Log = 1i32,
    Ln = 2i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrokerTransportQualityOfService {
    #[opcua(default)]
    NotSpecified = 0i32,
    BestEffort = 1i32,
    AtLeastOnce = 2i32,
    AtMostOnce = 3i32,
    ExactlyOnce = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseDirection {
    #[opcua(default)]
    Forward = 0i32,
    Inverse = 1i32,
    Both = 2i32,
    Invalid = 3i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseResultMask {
    #[opcua(default)]
    None = 0i32,
    ReferenceTypeId = 1i32,
    IsForward = 2i32,
    NodeClass = 4i32,
    BrowseName = 8i32,
    DisplayName = 16i32,
    TypeDefinition = 32i32,
    All = 63i32,
    ReferenceTypeInfo = 3i32,
    TargetInfo = 60i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ConversionLimitEnum {
    #[opcua(default)]
    NoConversion = 0i32,
    Limited = 1i32,
    Unlimited = 2i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataChangeTrigger {
    #[opcua(default)]
    Status = 0i32,
    StatusValue = 1i32,
    StatusValueTimestamp = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct DataSetFieldContentMask : i32 {
    const None = 0i32; const StatusCode = 1i32; const SourceTimestamp = 2i32; const
    ServerTimestamp = 4i32; const SourcePicoSeconds = 8i32; const ServerPicoSeconds =
    16i32; const RawData = 32i32; }
}
impl opcua::types::UaNullable for DataSetFieldContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for DataSetFieldContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for DataSetFieldContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for DataSetFieldContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for DataSetFieldContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for DataSetFieldContentMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for DataSetFieldContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for DataSetFieldContentMask {
    const TAG: &'static str = "DataSetFieldContentMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for DataSetFieldContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for DataSetFieldContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct DataSetFieldFlags : i16 { const
    None = 0i16; const PromotedField = 1i16; }
}
impl opcua::types::UaNullable for DataSetFieldFlags {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for DataSetFieldFlags {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        2usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i16(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for DataSetFieldFlags {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, ctx)?))
    }
}
impl Default for DataSetFieldFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for DataSetFieldFlags {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for DataSetFieldFlags {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for DataSetFieldFlags {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for DataSetFieldFlags {
    const TAG: &'static str = "DataSetFieldFlags";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for DataSetFieldFlags {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for DataSetFieldFlags {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataSetOrderingType {
    #[opcua(default)]
    Undefined = 0i32,
    AscendingWriterId = 1i32,
    AscendingWriterIdSingle = 2i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DeadbandType {
    #[opcua(default)]
    None = 0i32,
    Absolute = 1i32,
    Percent = 2i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DiagnosticsLevel {
    #[opcua(default)]
    Basic = 0i32,
    Advanced = 1i32,
    Info = 2i32,
    Log = 3i32,
    Debug = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum Duplex {
    #[opcua(default)]
    Full = 0i32,
    Half = 1i32,
    Unknown = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct EventNotifierType : u8 { const
    None = 0u8; const SubscribeToEvents = 1u8; const HistoryRead = 4u8; const
    HistoryWrite = 8u8; }
}
impl opcua::types::UaNullable for EventNotifierType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for EventNotifierType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        1usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_u8(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for EventNotifierType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, ctx)?))
    }
}
impl Default for EventNotifierType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for EventNotifierType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for EventNotifierType {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for EventNotifierType {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for EventNotifierType {
    const TAG: &'static str = "EventNotifierType";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for EventNotifierType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for EventNotifierType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ExceptionDeviationFormat {
    #[opcua(default)]
    AbsoluteValue = 0i32,
    PercentOfValue = 1i32,
    PercentOfRange = 2i32,
    PercentOfEURange = 3i32,
    Unknown = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum FilterOperator {
    #[opcua(default)]
    Equals = 0i32,
    IsNull = 1i32,
    GreaterThan = 2i32,
    LessThan = 3i32,
    GreaterThanOrEqual = 4i32,
    LessThanOrEqual = 5i32,
    Like = 6i32,
    Not = 7i32,
    Between = 8i32,
    InList = 9i32,
    And = 10i32,
    Or = 11i32,
    Cast = 12i32,
    InView = 13i32,
    OfType = 14i32,
    RelatedTo = 15i32,
    BitwiseAnd = 16i32,
    BitwiseOr = 17i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum HistoryUpdateType {
    Insert = 1i32,
    Replace = 2i32,
    Update = 3i32,
    Delete = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdentityCriteriaType {
    UserName = 1i32,
    Thumbprint = 2i32,
    Role = 3i32,
    GroupId = 4i32,
    Anonymous = 5i32,
    AuthenticatedUser = 6i32,
    Application = 7i32,
    X509Subject = 8i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdType {
    #[opcua(default)]
    Numeric = 0i32,
    String = 1i32,
    Guid = 2i32,
    Opaque = 3i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum InterfaceAdminStatus {
    #[opcua(default)]
    Up = 0i32,
    Down = 1i32,
    Testing = 2i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum InterfaceOperStatus {
    #[opcua(default)]
    Up = 0i32,
    Down = 1i32,
    Testing = 2i32,
    Unknown = 3i32,
    Dormant = 4i32,
    NotPresent = 5i32,
    LowerLayerDown = 6i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct JsonDataSetMessageContentMask :
    i32 { const None = 0i32; const DataSetWriterId = 1i32; const MetaDataVersion = 2i32;
    const SequenceNumber = 4i32; const Timestamp = 8i32; const Status = 16i32; const
    MessageType = 32i32; const DataSetWriterName = 64i32; const ReversibleFieldEncoding =
    128i32; const PublisherId = 256i32; const WriterGroupName = 512i32; const
    MinorVersion = 1024i32; }
}
impl opcua::types::UaNullable for JsonDataSetMessageContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for JsonDataSetMessageContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for JsonDataSetMessageContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for JsonDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for JsonDataSetMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for JsonDataSetMessageContentMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for JsonDataSetMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for JsonDataSetMessageContentMask {
    const TAG: &'static str = "JsonDataSetMessageContentMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for JsonDataSetMessageContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for JsonDataSetMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct JsonNetworkMessageContentMask :
    i32 { const None = 0i32; const NetworkMessageHeader = 1i32; const
    DataSetMessageHeader = 2i32; const SingleDataSetMessage = 4i32; const PublisherId =
    8i32; const DataSetClassId = 16i32; const ReplyTo = 32i32; const WriterGroupName =
    64i32; }
}
impl opcua::types::UaNullable for JsonNetworkMessageContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for JsonNetworkMessageContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for JsonNetworkMessageContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for JsonNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for JsonNetworkMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for JsonNetworkMessageContentMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for JsonNetworkMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for JsonNetworkMessageContentMask {
    const TAG: &'static str = "JsonNetworkMessageContentMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for JsonNetworkMessageContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for JsonNetworkMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MessageSecurityMode {
    #[opcua(default)]
    Invalid = 0i32,
    None = 1i32,
    Sign = 2i32,
    SignAndEncrypt = 3i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ModelChangeStructureVerbMask {
    NodeAdded = 1i32,
    NodeDeleted = 2i32,
    ReferenceAdded = 4i32,
    ReferenceDeleted = 8i32,
    DataTypeChanged = 16i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MonitoringMode {
    #[opcua(default)]
    Disabled = 0i32,
    Sampling = 1i32,
    Reporting = 2i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NamingRuleType {
    Mandatory = 1i32,
    Optional = 2i32,
    Constraint = 3i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NegotiationStatus {
    #[opcua(default)]
    InProgress = 0i32,
    Complete = 1i32,
    Failed = 2i32,
    Unknown = 3i32,
    NoNegotiation = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeAttributesMask {
    #[opcua(default)]
    None = 0i32,
    AccessLevel = 1i32,
    ArrayDimensions = 2i32,
    BrowseName = 4i32,
    ContainsNoLoops = 8i32,
    DataType = 16i32,
    Description = 32i32,
    DisplayName = 64i32,
    EventNotifier = 128i32,
    Executable = 256i32,
    Historizing = 512i32,
    InverseName = 1024i32,
    IsAbstract = 2048i32,
    MinimumSamplingInterval = 4096i32,
    NodeClass = 8192i32,
    NodeId = 16384i32,
    Symmetric = 32768i32,
    UserAccessLevel = 65536i32,
    UserExecutable = 131072i32,
    UserWriteMask = 262144i32,
    ValueRank = 524288i32,
    WriteMask = 1048576i32,
    Value = 2097152i32,
    DataTypeDefinition = 4194304i32,
    RolePermissions = 8388608i32,
    AccessRestrictions = 16777216i32,
    All = 33554431i32,
    BaseNode = 26501220i32,
    Object = 26501348i32,
    ObjectType = 26503268i32,
    Variable = 26571383i32,
    VariableType = 28600438i32,
    Method = 26632548i32,
    ReferenceType = 26537060i32,
    View = 26501356i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeClass {
    #[opcua(default)]
    Unspecified = 0i32,
    Object = 1i32,
    Variable = 2i32,
    Method = 4i32,
    ObjectType = 8i32,
    VariableType = 16i32,
    ReferenceType = 32i32,
    DataType = 64i32,
    View = 128i32,
}
#[opcua::types::ua_encodable]
///The possible encodings for a NodeId value.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum NodeIdType {
    #[opcua(default)]
    TwoByte = 0u8,
    FourByte = 1u8,
    Numeric = 2u8,
    String = 3u8,
    Guid = 4u8,
    ByteString = 5u8,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OpenFileMode {
    Read = 1i32,
    Write = 2i32,
    EraseExisting = 4i32,
    Append = 8i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OverrideValueHandling {
    #[opcua(default)]
    Disabled = 0i32,
    LastUsableValue = 1i32,
    OverrideValue = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct PasswordOptionsMask : i32 { const
    None = 0i32; const SupportInitialPasswordChange = 1i32; const SupportDisableUser =
    2i32; const SupportDisableDeleteForUser = 4i32; const SupportNoChangeForUser = 8i32;
    const SupportDescriptionForUser = 16i32; const RequiresUpperCaseCharacters = 32i32;
    const RequiresLowerCaseCharacters = 64i32; const RequiresDigitCharacters = 128i32;
    const RequiresSpecialCharacters = 256i32; }
}
impl opcua::types::UaNullable for PasswordOptionsMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for PasswordOptionsMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for PasswordOptionsMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for PasswordOptionsMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for PasswordOptionsMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for PasswordOptionsMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for PasswordOptionsMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for PasswordOptionsMask {
    const TAG: &'static str = "PasswordOptionsMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for PasswordOptionsMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for PasswordOptionsMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PerformUpdateType {
    Insert = 1i32,
    Replace = 2i32,
    Update = 3i32,
    Remove = 4i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct PermissionType : i32 { const None
    = 0i32; const Browse = 1i32; const ReadRolePermissions = 2i32; const WriteAttribute =
    4i32; const WriteRolePermissions = 8i32; const WriteHistorizing = 16i32; const Read =
    32i32; const Write = 64i32; const ReadHistory = 128i32; const InsertHistory = 256i32;
    const ModifyHistory = 512i32; const DeleteHistory = 1024i32; const ReceiveEvents =
    2048i32; const Call = 4096i32; const AddReference = 8192i32; const RemoveReference =
    16384i32; const DeleteNode = 32768i32; const AddNode = 65536i32; }
}
impl opcua::types::UaNullable for PermissionType {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for PermissionType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for PermissionType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for PermissionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for PermissionType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for PermissionType {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for PermissionType {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for PermissionType {
    const TAG: &'static str = "PermissionType";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for PermissionType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for PermissionType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct PubSubConfigurationRefMask : i32
    { const None = 0i32; const ElementAdd = 1i32; const ElementMatch = 2i32; const
    ElementModify = 4i32; const ElementRemove = 8i32; const ReferenceWriter = 16i32;
    const ReferenceReader = 32i32; const ReferenceWriterGroup = 64i32; const
    ReferenceReaderGroup = 128i32; const ReferenceConnection = 256i32; const
    ReferencePubDataset = 512i32; const ReferenceSubDataset = 1024i32; const
    ReferenceSecurityGroup = 2048i32; const ReferencePushTarget = 4096i32; }
}
impl opcua::types::UaNullable for PubSubConfigurationRefMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for PubSubConfigurationRefMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for PubSubConfigurationRefMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for PubSubConfigurationRefMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for PubSubConfigurationRefMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for PubSubConfigurationRefMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for PubSubConfigurationRefMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for PubSubConfigurationRefMask {
    const TAG: &'static str = "PubSubConfigurationRefMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for PubSubConfigurationRefMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for PubSubConfigurationRefMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubDiagnosticsCounterClassification {
    #[opcua(default)]
    Information = 0i32,
    Error = 1i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubState {
    #[opcua(default)]
    Disabled = 0i32,
    Paused = 1i32,
    Operational = 2i32,
    Error = 3i32,
    PreOperational = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum RedundancySupport {
    #[opcua(default)]
    None = 0i32,
    Cold = 1i32,
    Warm = 2i32,
    Hot = 3i32,
    Transparent = 4i32,
    HotAndMirrored = 5i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum RedundantServerMode {
    #[opcua(default)]
    PrimaryWithBackup = 0i32,
    PrimaryOnly = 1i32,
    BackupReady = 2i32,
    BackupNotReady = 3i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum SecurityTokenRequestType {
    #[opcua(default)]
    Issue = 0i32,
    Renew = 1i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ServerState {
    #[opcua(default)]
    Running = 0i32,
    Failed = 1i32,
    NoConfiguration = 2i32,
    Suspended = 3i32,
    Shutdown = 4i32,
    Test = 5i32,
    CommunicationFault = 6i32,
    Unknown = 7i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum StructureType {
    #[opcua(default)]
    Structure = 0i32,
    StructureWithOptionalFields = 1i32,
    Union = 2i32,
    StructureWithSubtypedValues = 3i32,
    UnionWithSubtypedValues = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TimestampsToReturn {
    #[opcua(default)]
    Source = 0i32,
    Server = 1i32,
    Both = 2i32,
    Neither = 3i32,
    Invalid = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TrustListMasks {
    #[opcua(default)]
    None = 0i32,
    TrustedCertificates = 1i32,
    TrustedCrls = 2i32,
    IssuerCertificates = 4i32,
    IssuerCrls = 8i32,
    All = 15i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct TrustListValidationOptions : i32
    { const None = 0i32; const SuppressCertificateExpired = 1i32; const
    SuppressHostNameInvalid = 2i32; const SuppressRevocationStatusUnknown = 4i32; const
    SuppressIssuerCertificateExpired = 8i32; const SuppressIssuerRevocationStatusUnknown
    = 16i32; const CheckRevocationStatusOnline = 32i32; const
    CheckRevocationStatusOffline = 64i32; }
}
impl opcua::types::UaNullable for TrustListValidationOptions {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for TrustListValidationOptions {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for TrustListValidationOptions {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for TrustListValidationOptions {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for TrustListValidationOptions {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for TrustListValidationOptions {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for TrustListValidationOptions {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for TrustListValidationOptions {
    const TAG: &'static str = "TrustListValidationOptions";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for TrustListValidationOptions {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for TrustListValidationOptions {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TsnFailureCode {
    #[opcua(default)]
    NoFailure = 0i32,
    InsufficientBandwidth = 1i32,
    InsufficientResources = 2i32,
    InsufficientTrafficClassBandwidth = 3i32,
    StreamIdInUse = 4i32,
    StreamDestinationAddressInUse = 5i32,
    StreamPreemptedByHigherRank = 6i32,
    LatencyHasChanged = 7i32,
    EgressPortNotAvbCapable = 8i32,
    UseDifferentDestinationAddress = 9i32,
    OutOfMsrpResources = 10i32,
    OutOfMmrpResources = 11i32,
    CannotStoreDestinationAddress = 12i32,
    PriorityIsNotAnSrcClass = 13i32,
    MaxFrameSizeTooLarge = 14i32,
    MaxFanInPortsLimitReached = 15i32,
    FirstValueChangedForStreamId = 16i32,
    VlanBlockedOnEgress = 17i32,
    VlanTaggingDisabledOnEgress = 18i32,
    SrClassPriorityMismatch = 19i32,
    FeatureNotPropagated = 20i32,
    MaxLatencyExceeded = 21i32,
    BridgeDoesNotProvideNetworkId = 22i32,
    StreamTransformNotSupported = 23i32,
    StreamIdTypeNotSupported = 24i32,
    FeatureNotSupported = 25i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TsnListenerStatus {
    #[opcua(default)]
    None = 0i32,
    Ready = 1i32,
    PartialFailed = 2i32,
    Failed = 3i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TsnStreamState {
    #[opcua(default)]
    Disabled = 0i32,
    Configuring = 1i32,
    Ready = 2i32,
    Operational = 3i32,
    Error = 4i32,
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TsnTalkerStatus {
    #[opcua(default)]
    None = 0i32,
    Ready = 1i32,
    Failed = 2i32,
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UadpDataSetMessageContentMask :
    i32 { const None = 0i32; const Timestamp = 1i32; const PicoSeconds = 2i32; const
    Status = 4i32; const MajorVersion = 8i32; const MinorVersion = 16i32; const
    SequenceNumber = 32i32; }
}
impl opcua::types::UaNullable for UadpDataSetMessageContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for UadpDataSetMessageContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for UadpDataSetMessageContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for UadpDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for UadpDataSetMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for UadpDataSetMessageContentMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for UadpDataSetMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for UadpDataSetMessageContentMask {
    const TAG: &'static str = "UadpDataSetMessageContentMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for UadpDataSetMessageContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for UadpDataSetMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UadpNetworkMessageContentMask :
    i32 { const None = 0i32; const PublisherId = 1i32; const GroupHeader = 2i32; const
    WriterGroupId = 4i32; const GroupVersion = 8i32; const NetworkMessageNumber = 16i32;
    const SequenceNumber = 32i32; const PayloadHeader = 64i32; const Timestamp = 128i32;
    const PicoSeconds = 256i32; const DataSetClassId = 512i32; const PromotedFields =
    1024i32; }
}
impl opcua::types::UaNullable for UadpNetworkMessageContentMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for UadpNetworkMessageContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for UadpNetworkMessageContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for UadpNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for UadpNetworkMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for UadpNetworkMessageContentMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for UadpNetworkMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for UadpNetworkMessageContentMask {
    const TAG: &'static str = "UadpNetworkMessageContentMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for UadpNetworkMessageContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for UadpNetworkMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UserConfigurationMask : i32 {
    const None = 0i32; const NoDelete = 1i32; const Disabled = 2i32; const NoChangeByUser
    = 4i32; const MustChangePassword = 8i32; }
}
impl opcua::types::UaNullable for UserConfigurationMask {
    fn is_ua_null(&self) -> bool {
        self.is_empty()
    }
}
impl opcua::types::BinaryEncodable for UserConfigurationMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for UserConfigurationMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for UserConfigurationMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for UserConfigurationMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlDecodable for UserConfigurationMask {
    fn decode(
        stream: &mut opcua::types::xml::XmlStreamReader<&mut dyn std::io::Read>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlEncodable for UserConfigurationMask {
    fn encode(
        &self,
        stream: &mut opcua::types::xml::XmlStreamWriter<&mut dyn std::io::Write>,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        self.bits().encode(stream, ctx)
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::XmlType for UserConfigurationMask {
    const TAG: &'static str = "UserConfigurationMask";
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for UserConfigurationMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for UserConfigurationMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[opcua::types::ua_encodable]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum UserTokenType {
    #[opcua(default)]
    Anonymous = 0i32,
    UserName = 1i32,
    Certificate = 2i32,
    IssuedToken = 3i32,
}
